代理模式：  
*  代理要做的：控制和访问  
*  所谓代理，就是代表某个真实的对象。  
*  远程代理好比是“远程对象的本地代表”。  
    * 远程对象：这是一种活在不同的java虚拟机堆（或者说是，在不同的地址空间运行的远程对象）中的对象  
    * 本地代表：这是一种可以由本地方法调用的对象，其行为会转发到远程对象中  
*  被代理的对象就像是在做远程方法调用，但其实只是调用本地堆中的“代理”对象上的方法，再由代理处理所有的网络通信的底层细节  
   
远程方法：  
  * 我们需要一些辅助对象，帮助我们在客户对象和服务对象之间进行沟通。
  * 客户的辅助对象不是真正的远程服务，它服务于客户，让客户对象误以为自己调用的是服务对象
  * 服务的辅助对象从客户辅助对象接受请求(通过socket连接)，将调用信息解包，然后调用真正的服务对象，然后获取服务对象的返回值，发回至客户的辅助对象。
  * 客户的辅助对象将信息解包，然后将辅助对象发给客户对象  
* RMI:  
  * Remote Method Invocation
  * RMI提供了客户辅助对象和服务辅助对象
  * RMI的好处在于你不必亲自写任何网络或IO代码。
  * RMI提供了运行时的基础设施，这包括了查找服务(lookup service)，可以使用该服务来寻找和访问请远程对象
  * RMI将客户辅助对象成为stub(桩)，将服务辅助对象成为skeleton(骨架)
  
制作远程服务流程：  
  1. 制作远程接口：  
    1） 扩展java.rmi.Remote。该接口是一个记号接口，所以Remote不具有方法。对于RMI来说，Remote接口具有特别的意义。  
    2） 声明所有的方法都会抛出RemoteException。客户使用远程接口调用服务，客户会使用调用实现远程接口stub上的方法，而stub底层用到了网络和IO，所以各种坏事情都有可能发生。  
    3） 确定变量和返回值能被序列化。因为涉及网络传输，所以序列化是必须的。  
  2. 制作远程实现  
    1） 实现远程接口  
    2） 扩展java.rmi.server.UnicastRemoteObject以获得某些“远程的”功能，使之成为远程服务对象。  
    3） 遵循UnicastRemoteObject的规范，创建一个无参且抛出RemoteException构造器  
    4） 利用RMI Registry注册此服务。(就像dubbo，需要zk注册中心一样)
  3. 利用rmic产生的tub和skeleton  
    1） 在远程实现类上执行rmic
  4. 启动RMI registry  
    1） 开启一个终端，执行rmiregistry
  5. 开始远程服务  
    1)  开启另一个终端，启动服务