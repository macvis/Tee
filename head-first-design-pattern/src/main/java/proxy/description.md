代理模式：  
*  代理要做的：控制和访问  
*  所谓代理，就是代表某个真实的对象。  
*  远程代理好比是“远程对象的本地代表”。  
    * 远程对象：这是一种活在不同的java虚拟机堆（或者说是，在不同的地址空间运行的远程对象）中的对象  
    * 本地代表：这是一种可以由本地方法调用的对象，其行为会转发到远程对象中  
*  被代理的对象就像是在做远程方法调用，但其实只是调用本地堆中的“代理”对象上的方法，再由代理处理所有的网络通信的底层细节  
   
远程方法：  
  * 我们需要一些辅助对象，帮助我们在客户对象和服务对象之间进行沟通。
  * 客户的辅助对象不是真正的远程服务，它服务于客户，让客户对象误以为自己调用的是服务对象
  * 服务的辅助对象从客户辅助对象接受请求(通过socket连接)，将调用信息解包，然后调用真正的服务对象，然后获取服务对象的返回值，发回至客户的辅助对象。
  * 客户的辅助对象将信息解包，然后将辅助对象发给客户对象  
* RMI:  
  * Remote Method Invocation
  * RMI提供了客户辅助对象和服务辅助对象
  * RMI的好处在于你不必亲自写任何网络或IO代码。
  * RMI提供了运行时的基础设施，这包括了查找服务(lookup service)，可以使用该服务来寻找和访问请远程对象
  * RMI将客户辅助对象成为stub(桩)，将服务辅助对象成为skeleton(骨架)
  
制作远程服务流程：  
  1. 制作远程接口：  
    1） 扩展java.rmi.Remote。该接口是一个记号接口，所以Remote不具有方法。对于RMI来说，Remote接口具有特别的意义。  
    2） 声明所有的方法都会抛出RemoteException。客户使用远程接口调用服务，客户会使用调用实现远程接口stub上的方法，而stub底层用到了网络和IO，所以各种坏事情都有可能发生。  
    3） 确定变量和返回值能被序列化。因为涉及网络传输，所以序列化是必须的。  
  2. 制作远程实现  
    1） 实现远程接口  
    2） 扩展java.rmi.server.UnicastRemoteObject以获得某些“远程的”功能，使之成为远程服务对象。  
    3） 遵循UnicastRemoteObject的规范，创建一个无参且抛出RemoteException构造器  
    4） 利用RMI Registry注册此服务。(就像dubbo，需要zk注册中心一样)
  3. 利用rmic产生的tub和skeleton  
    1） 在远程实现类上执行rmic
  4. 启动RMI registry  
    1） 开启一个终端，执行rmiregistry
  5. 开始远程服务  
    1)  开启另一个终端，启动服务  
    
代理模式：  
* 为另一个对象提供一个替身或占位符以控制对这个对象的访问  

代理控制访问：  
* 代理之所以需要控制访问，是因为客户不知道如何和远程对象沟通。从某个方面来看，远程代理控制访问，好帮我们处理网络上的细节。
* 几种代理控制访问的方式：
    1) 远程代理控制访问远程对象
    2) 虚拟代理控制访问创建开销大的资源
    3) 保护代理基于权限控制对资源的访问  

虚拟代理：  
* 如果服务对象的创建开销比较大，虚拟代理会帮助我们创建一个对象，在对象的创建前和创建中时，由虚拟代理来扮演对象本身。
* 对象创建后，代理就会直接将请求委托至对象。
* 之所以是虚拟的， 因为一般的代理不会去创建对象，只负责接受和发送，进而就会对对象造成了印象，而不是真正意义上的代理了。

动态代理：  
* 动态代理之所以被称为动态代理，是因为运行时才创建它，代码开始执行时，还没有proxy类。  
  
典型的代理类：  
* 防火墙，Firewall Proxy
    * 控制网络资源的访问，保护主题免于坏客户的侵害
    * 在各大公司的防火墙中常见
* 智能引用代理，Smart Reference Proxy
    * 当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数
* 缓存代理，Caching Proxy
    * 为开销大的运算结果提供暂时的存储，同时也允许多个客户共享结果，以减少计算或网络延迟
    * 应用于web服务器代理，或内容管理与出版系统
* 同步代理，Synchronization Proxy
    * 在多线程的情况下为主题提供安全的访问
    * 常应用于JavaSpaces，为分散式环境内的潜在对象集合提供同步访问控制
* 复杂隐藏代理，Complexity Hiding Proxy
    * 用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时候也成为外观代理(Facade Proxy)。复杂隐藏代理和外观模式是不一样的，因为代理控制访问，而外观模式只提供另一组接口。
* 写入时复制代理，Copy-On-Write Proxy
    * 用来控制对象的复制，方法是延迟对象的复制，直到客户需要位置。这是虚拟代理的变体
    * 例如CopyOnWriteArrayList.class
