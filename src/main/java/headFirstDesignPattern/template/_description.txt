Head First Design Pattern, page275-313

模板方法模式之封装算法：
    1.我们做了什么：
        1) 分析：
            茶 - (把水煮沸，用沸水浸泡茶叶，把茶倒进杯子，加柠檬)
            咖啡 - (把水煮沸，用沸水冲泡咖啡粉，把咖啡倒进杯子，加糖和牛奶)
        2）抽象：
            咖啡因饮料 - (把水煮沸，冲泡，把饮料倒进杯子，加调料)，@See CaffeineBeverage
            且一些步骤依赖子类进行：
                茶 - 重写冲泡()方法为用沸水浸泡茶叶()，重写加调料()方法为加柠檬()
                咖啡 - 重写冲泡()方法为用沸水冲泡咖啡()，重写加调料()方法为加糖和牛奶()
            -> 咖啡因饮料了解和控制冲泡方法的步骤，亲自执行步骤把水煮沸和把饮料倒进杯子，
               但依赖茶和咖啡来完成冲泡和加调料

    2.认识模板方法：
        CaffeineBeverage.prepareRecipe()方法是我们的模板方法，因为：
            1) 毕竟它是一个方法
            2）它作用一个算法的模板，在这个例子中，算法是用来制作咖啡因饮料的
            3）在这个模板中，算法内的每一个步骤都被一个方法代表了
            4）某些方法则是由子类处理的

        -> 定义：
            模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现

        -> 模板模方法给我们带来什么？
            1）由模板类(@See CaffeineBeverage)主导一切，它拥有算法，
               并且保护这个算法(finale prepareRecipe())
            2）对子类来说，CaffeineBeverage类的存在，可以将代码的复用最大化
            3）算法只存在于一个地方，所以容易修改
            4）这个模板方法提供了一个框架，可以让其他的咖啡因饮料插进来。新的
               咖啡因饮料只需要实现自己的方法就可以了
            5）CaffeineBeverage类专注在算法本身，而由子类提供完整的实现
    3.模板方法模式的定义：
        -> 在一个方法中定义一个算法的股价，而将一些步骤延迟到子类中。模板方法使得
           子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤
       ----------------------------------------------------------------
        public abstract class AbstractClass{
            final void templateMethod(){
                primitiveOperation1();
                primitiveOperation2();
                concreteOperation();
            };
            abstract primitiveOperation1();
            abstract primitiveOperation2();

            void concreteOperation(){
                //do something
            }

            /**
             * 这是一个默认不做事的方法。
             * 子类可以选择不覆盖它们
             */
            void hook(){}
        }

        public class ConcreteClass extends AbstractClass{
            @Override
            primitiveOperation1(){
                //do something
            }

            @Override
            primitiveOperation1(){
                //do something
            }
        }
        ----------------------------------------------------------------
        分析：
        1. AbstractClass这个抽象类包含了模板方法
            1） 模板方法在实现算法的过程中，用到了这两个原语操作。
                模板方法本身和这两个原语操作的具体实现之间被解耦了
            2） 这个模板方法所用到的操作的抽象版本
        2. ConcreteClass是具体类之一
            1） 每一个都实现了模板方法所需的全部操作
            2） 这个具体类实现抽象的操作，当木板方法需要者两个抽象方法时，
                会调用他们
        3. 关于hook()钩子方法：
           钩子是一种被声明在抽象类方法，但只有空的或者默认的实现。
           钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要
           挂钩，由子类自行决定

    4. Q/A
        1）当我创建一个模板方法时，怎么才能知道什么时候该使用抽象方法，什么时候使用钩子？
           当你的子类必须实现提供算法中某个方法或步骤的实现时，就使用抽象方法。
           如果算法的这个部分时刻选的，就用钩子。
           如果是钩子的话，子类可以选择实现这个钩子，但并不强制这么做

        2）使用钩子真正目的是什么：
           钩子有几种用法。如我们之前所说的，钩子可以让子类实现算法中可选的部分，
           或者在钩子对于子类的实现并不重要的时候，子类可以对此钩子置之不理。
           钩子的另一个用法，是让子类能够有机会对模板方法中某些即将发生或者是刚刚
           发生的步骤做出反应。

        3）子类必须实现抽象类中的所有方法吗？
           是的。不仅仅是java，其他语言也一样。
           因为模板方法要求其提供所有未定义步骤的完整实现

        4）似乎我应该保持抽象方法的数目越少越好，否则，在子类中实现这些方法将会很麻烦：
           当你在写模板方法的时候，心里要随时记得这一点。想要做到这一点，
           可以让算法内的步骤不要切割的太细。但是如果步骤太瘦的话，会比较
           没有弹性，所以要看情况折衷。
           也请记住，某些步骤是可选的，所以你可以将这些步骤实现成钩子，而
           不是实现成抽象方法，这样就可以让抽象类的子类的负荷减轻。
    5. 设计原则之好莱坞原则
        ->  别调用我们，我们会调用你
        依赖腐败：
            当高层组件依赖底层组件，而低层组件又依赖高层组件，而高层组件又
            依赖鞭策组件，而边侧组件又依赖底层组件式，依赖腐败就发生了。
        Q/A：
            1）好莱坞原则和依赖倒置原则之间的关系如何？
               依赖倒置原则叫我们尽量避免使用具体类，而多使用抽象。而好莱坞原则是用在
               创建框架或组件上的一种技巧，好让低层组件能够被挂钩进计算中，而且又不会
               让高层组件依赖低层组件。两者的目标都是在于解耦，但是依赖倒置原则更加注
               重如何在设计中避免依赖。
               好莱坞原则教我们一个技巧，创建一个有弹性的设计，允许低层结构能够互相操
               作，而又放置其他类太过依赖他们。

            2）底层组件不可以调用高层组件中的方法吗？
               并不尽然。事实上，低层组件在结束是，常常会调用从超类中继承来的方法。我
               们所要做的是，避免让高层和低层之间有明显的环状依赖

    6. 总结：
        1）模板方法定义了算法的步骤，把这些步骤的实现延迟到子类
        2）模板方法模式为我们提供了一种代码复用的重要技巧
        3）模板方法的抽象类可以定义具体方法、抽象方法和钩子
        4）抽象方法由子类实现
        5）钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，
           子类可以选择要不要去覆盖它
        6）为了防止子类改变模板方法中的算法，可以将模板方法声明为final
        7）好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及
           何时调用低层模块
        8）你将在真实世界代码中看到模板方法模式的许多变体，不要期待它们
           全都是第一眼就可以被认出的
        9）策略模式和模板方法模式都封装算法，一个用组合，一个用继承
        10）工厂方法是模板方法的一种特殊版本