来自Head First Design第七章，page235

适配器模式：
    即将一个接口转换成另一个接口，以符合客户的期望
    将一个类的接口，转换成客户期望的另一个接口。
    适配器然原本接口不兼容的类可以合作

实际上有两种适配器：
    对象适配器
        -> 是与接口绑定的，因为这样就不必关注实现，从而实现与对象的适配
    类适配器
        -> 需要多重继承才能实现的适配器，但是Java中是不可能的
        -> 但在其他可多继承的语言上可能会碰到这样的需求

对象适配器和类适配器使用两种不同的适配方法，即组合和继承，这两种实现的差异如何影响适配器的弹性？
    ->  组合可以只关注接口，而不必关注该接口的具体实现是什么，
        进而对所有实现该接口的对象进行统一控制。
        所以在弹性上相比继承要好很多。
    ->  使用继承时，因为适配器模式需要适配两个或两个以上的对象，所以需要多继承
        且实现好的适配器只关注被适配的两个类。
        一旦被适配类新增或修改了实现时，类适配器也要相应的修改
        所以弹性相比组合要低很多，或者说几乎没有弹性

外观模式：
    ->  适配器模式的一个扩展，可以直接使用适配器中已实现的一个或者多个功能
    ->  Java API中最典型的Facade模式应用场景即JDBC，因为封装了很多连接的方法
    ->  避免让客户和子系统之间的紧耦合

适配器模式和外观模式的意图：
    适配器模式：改变接口，符合客户的期望，同时也将客户从组件的子系统中解耦
    外观模式：提供子系统的一个简化接口

最小知识原则（德墨忒尔法则）：
    ->  该方法本身
    ->  被当做方法的参数而传递进来的对象
    ->  此方法所创建或实例化的任何对象
    ->  对象的任何组件

如何贯彻最小知识原则，即不要影响太多对象：
    ->  让被调用对象提供一个能直接被调用的方法

总结：
    1）当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器
    2）当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观
    3）适配器改变接口以符合客户的期望
    4）外观将客户从一个复杂的子系统中解耦
    5）实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定
    6）实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行
    7）适配器模式有两种形式：对象适配器和类适配器。类适配器需要用到多重继承
    8）你可以为一个子系统实现一个以上的外观
    9） -> 适配器将一个对象包装起来以改变其接口；
        -> 装饰者讲一个对象包装起来一增加新的行为和责任
        -> 而外观将一群对象包装起来以简化其接口