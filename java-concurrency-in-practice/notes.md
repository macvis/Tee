Java并发编程实战  
--  

####前言
* 要点：  
    1. 线程也被称为轻量级进程
    2. 线程带来的风险：
        1) 安全性
        2) 活跃性：  
            在开发并发代码时，一定要注意线程安全性是不可破坏的
        3) 性能问题：  
            在多线程程序中，当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁的出现上下文切换操作，这种操作将带来极大的开销：  
            保存和恢复执行上下文，丢失局部性，并且CPU时间将更多的花在线程调度而不是线程运行上。
    4. 线程无处不在：  
        框架通过在框架线程中调用应用程序代码将并发性引入到程序中。在代码中将不可避免的访问应用程序状态，因此所有访问这些状态的代码路径都必须是线程安全的。  
    5. 几个在应用程序之外的线程中调用应用程序的代码(是不是守护线程?)  
        java.util.Timer;  
        各种Servlet;   
        RMI

###第一部分，基础知识  
####2.0 线程安全性
* 要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的(Shared)和可变的(Mutable)状态的访问
    * 共享，意味着变量可以由多个线程同时访问
    * 可变，意味着变量的值在其生命周期内可以发生变化
    - 一个对象是否需要是线程安全的，取决于它是否被多个线程访问
    - 要使得对象时线程安全的，就需要使用同步机制来协同对对象可变状态的访问
    - 在编写并发应用程序时，一种正确的编程方法就是：首先使代码正确运行，然后再提高代码的速度

####2.1 什么是线程安全性
* 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行文，那么就称这个类时线程安全的。  

示例1：一个无状态的Servlet
```java
@ThreadSafe
public class StatelessFactorizer implements Servlet{
    public void service(ServletRequest req, ServletResponse resp){
        java.math.BigInteger i = extractFromRequest(req);
        java.math.BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }
}
```
StatelessFactorizer是无状态的：既不包含任何域，也不包含任何对其他类中域的引用。
* 无状态对象一定是线程安全的。
    * 大多数Servlet都是无状态的。
    * 只有当Servlet在处理请求时需要保存一些信息，线程安全性才会成为一个问题   
    
####2.2 原子性  

示例2：在没有同步的情况下统计已处理请求数量的Servlet(不安全，不能这么写)
```java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet{
    private long count = 0;
    public long getCount(){
        return count;
    }
    public void service(ServletRequest req, ServletResponse res){
        java.math.BigInteger i = extractFromRequest(req);
        java.math.BigInteger[] factors = factor(i);
        count++;
        encodeIntoResponse(res, factors);
    }
}
```
上述类是非线程安全的，虽然能在单线程环境中正确运行，但是很可能会丢失一些更新操作。虽然递增操作count++是一种紧凑的语法，使其看上去只是一个操作，但这个操作并非原子的，因而它并不会作为一个不可分割的操作来执行  
* 在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：**竞态条件**。
####2.2.1 竞态条件  
* 当某个计算结果的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件
    * 最常见的竞态条件类型就是先检查后执行(check-then-act)操作，即通过一个可能失效的观测结果来决定下一步的动作  
    * 要获得正确的结果，必须取决于时间的发生时序。
* 竞态条件的本质：基于一种可能失效的观察结果来做出判断或者执行某个计算，举例：
```text
A和B约在一号大街的星巴克见面。
然后A赶到一号大街时却发现有两个星巴克。
于是A进入第一家星巴克，没有看到B，只好走出来。
就在A走出第一家星巴克的时候，B也赶到第一家星巴克，只是B从后门进的。
所以这就是一种失效的观察结果

即先检查，后执行
```
####2.2.2 延迟初始化中的竞态条件
* 延迟初始化：将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。
示例：延迟初始化中的竞态条件，不要这么做
```java
public class LazyInitRace{
    private ExpensiveObject instance = null;
    public ExpensiveObject getInstance(){
        if(instance == null){
            instance = new ExpensiveObject();
            return instance;
        }
    }
}
```
上述例子中，如果同时有两个线程执行getInstance，那么A看到instance为空的同时，B也在调用getInstance方法，那么此时的instance是否为空，要取决于不可预测的时序，包括线程的调度方式，以及A需要花费多长时间来初始化ExpensiveObject并设置Instance。如果当B检查时，instance为空没那么在两次调用getInstance时可能会得到不同的结果  
* 与大多数并发错误一样，竞态条件并不总是会产生错误，还需要某种不恰当的执行时序。
* 原子操作：  
假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作(包括该操作本身)来说，这个操作是一个已原子方式执行的操作。

```java
//程序2.4
@ThreadSafe
public class CountingFactorizer implements Servlet{
    private final AtomicLong count = new AtomicLong(0);
    
    public long getCount(){
        return count.get();
    }
    
    public void service(ServletRequest req, ServletResponse resp){
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        count.incrementAndGet();
        encodeIntoResponse(resp, factors);
    }
}
```
AtomicLong能保证所有对计数器状态的访问操作都是原子的。

####2.3.1 重入
* 概念：  
  当某个线程请求一个有其他线程持有的线程时，发出的请求线程就会阻塞。然而，由于内置的锁是可重入的，因此如果某个线程试图获得一个已经**由他自己持有**的锁，那么这个请求就会成功。
* 重入，意味着获取锁的操作的粒度是"线程"而不是"调用"  
  粒度：指的是一个方法内所包含的逻辑复杂度。若把一次调用视作一个逻辑，那么线程则具有多个逻辑，则粒度变大  
  
####2.4 用锁来保护状态
* 锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。  
  串行访问：意味着多个线程**依次**以独占的方式访问对象，而不是并发访问  
* 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的
* 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁

####2.5 活跃性与性能
* 尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享变量
* 通常，在**简单性**与性能之间存在着相互制约的因素，当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性(可能会破坏安全性)  
  简单性：指的是编码时的简单，例如用一大块synchronized/try-catch代码块将代码包裹起来
* 当执行时间较长的计算或者无法可能快速完成的操作时(网络I/O，控制台I/O)，一定不要持有锁

#### 3 对象的共享
#### 3.1 可见性
* 可见性中的错误总是会违背我们的直觉
* 重排序(Reordering)：  
1. 在没有同步的情况下，jvm允许cpu对操作顺序重新排序，以使jvm充分利用现代多核处理器的性能  
2. 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。
* 只要有数据在多个线程之间共享，就能正确的使用同步，得到我们想要的结果
#### 3.1.2 非原子的64位操作
* java内存模型要求，变量的读取操作和写入操作都必须是原子操作
* **但是**对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位操作。这就带来了非原子性操作的隐患  
#### 3.1.3 加锁与可见性
* 内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果
* 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步
#### 3.1.4 volatile变量
* volatile是一个比synchronized关键字更轻量级的同步机制
* 当一个变量被声明为volatile后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序
* 使用场景：  
1. 能简化代码的实现以及对同步策略的验证时；  
2. 确保它们自身状态的可见性；  
3. 确保它们所引用对象的状态的可见性；  
4. 标识一些重要的程序生命周期事件的发生(eg. 初始化或关闭)  
5. 通常用作某个操作完成、发生中断或者其他状态的标识，如下列代码中的asleep变量
```java
class Foo{
    volatile boolean asleep;

    public void foo(){
        while(asleep){
            countSomeSheep();
        }
    }
}
```
6. volatile的语义不足以确保递增操作的原子性，除非你能确保只有一个线程对变量执行写操作。
```text
例如你让一个volatile的integer自增（i++），其实要分成3步：
1）读取volatile变量值到local； 
2）增加变量的值；
3）把local的值写回，让其它的线程可见。

这3步的jvm指令为：
1 mov    0xc(%r10),%r8d ; Load
2 inc    %r8d           ; Increment
3 mov    %r8d,0xc(%r10) ; Store
4 lock   addl $0x0,(%rsp) ; StoreLoad Barrier
注意最后一步是内存屏障。

什么是内存屏障（Memory Barrier）？
内存屏障（memory barrier）是一个CPU指令。
基本上，它是这样一条指令： 
a) 确保一些特定操作执行的顺序； 
b) 影响一些数据的可见性(可能是某些指令执行后的结果)。
编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。
插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。
内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，
这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。

内存屏障（memory barrier）和volatile什么关系？
上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，
在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：
1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。
2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。

volatile为什么没有原子性?
明白了内存屏障（memory barrier）这个CPU指令，回到前面的JVM指令：
从Load到store到内存屏障，一共4步，
其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，
但中间的几步（从Load到Store）是不安全的，中间如果其他的CPU修改了值将会丢失。
```
7. 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性
8. 当且仅当满足以下所有条件时，才可以使用volatile变量  
* 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值
* 该变量不会与其他状态变量一起纳入不变性条件中
* 在访问变量时不需要加锁

#### 3.2 发布与逸出
* 发布：发布一个对象指的是，是对象能够在当前作用域之外的代码中使用。
* 逸出：当某个不应该被发布的对象被发布时，这种情况就是逸出。
* 不要在构造过程中使this引用逸出
* 当对象在构造函数中创建一个线程时，无论是显式创建(通过将它传给构造函数)，还是隐式创建(由于Thread或Runnable是该对象的一个内部类)，this引用都会被新创建的线程共享。
* 在构造函数中调用一个可改写的实例方法时，同样对导致this引用在构造过程中逸出。

#### 3.3 线程封闭
* 数据的共享需要使用同步。
* 线程封闭：如果是仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭
* 线程封闭同时也是实现线程安全性最简单的方式之一。
* 当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身就不是线程安全的。
* 线程封闭的常见应用是JDBC的Connection对象。

#### 3.3.1 Ad-hoc线程封闭
* 概念：维护线程封闭性的职责完全由程序实现来承担。
* 在某些情况下，单线程子系统提供的简便性要胜过Ad-hoc线程封闭技术的脆弱性，另外一个原因也是为了避免死锁。
* volatile变量还存在一种特殊的线程封闭。只要能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全的在这些共享的volatile变量上执行"读取-修改-写入"的操作。
* volatile变量的可见性还确保了其他线程能看到最新的值。
* Ad-hoc因为比较脆弱，所以尽量少用。更多的使用栈封闭或ThreadLocal类

#### 3.3.2 栈封闭
* 也被称为成骨内部使用或者线程局部使用。
* 在栈封闭中，只能通过局部变量才能访问对象。
* 局部变量的固有属性之一就是封闭在执行线程中。
* 将变量的初始化操作封闭在方法中，可以避免逸出。

#### 3.3.3 ThreadLocal
* ThreadLocal类的get总是返回当前执行线程在调用set时设置的最新值。
* 通常用于防止对可变的单实例变量(Singleton)或全局变量进行共享，eg JDBC。
* 将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象，可以维持线程安全性。

#### 3.4 不变性
* 如果一个对象在被创建后期状态就不能被修改，那么这个对象就被称为不可变对象。
* 线程安全性是不可变对象的固有属性之一。
* 不可变对象一定是线程安全的。

#### 3.4.1 final域
* final域能确保初始化过程中的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步

#### 3.5 安全发布
#### 3.5.1 不正确的发布：正确的对象被破坏
```java
public class Holder{
    private int n;
    
    public Holder(int n){
        this.n = n;
    }
    
    //若holder未被正确发布，则会报出该error
    public void assertSanity(){
        if(n != n){
            throw new AssertionError("this statement is false");
        }
    }
}
```
* 上面代码中，有一个情况是，线程看到的holder引用值是最新的，但Holder状态的值却是失效的。  
```text
    失效值：
    Object的构造函数会在子类构造函数运行之前先将默认值写入所有的域
```

#### 3.5.2 不可变对象与初始化安全性
* 为确保对象状态能呈现出一致的视图，就*必须使用同步*。
* 不可变对象在发布时，即便没有使用同步，仍然可以安全的访问该对象。
* 任何线程都可以在不需要额外同步的情况下安全的访问不可变对象，即使在发布这些对象时没有使用同步。

#### 3.5.3 安全发布的常用模式
* 要安全的发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全的发布：
```text
1. 在构建初始化函数中初始化一个对象引用；
2. 将对象的引用保存到volatile类型的域或者AtomicReference对象中；
3. 将对象的引用保存到某个正确构造对象的final类型域中；
4. 将对象的引用保存到一个由锁保护的域中；
```
* 常用的线程安全容器：
```text
    HashTable           SynchronizedMap             ConcurrentMap
    Vector              CopyOnWriteArrayList        CopyOnWriteArraySet         SynchronizedList        SynchronizedSet
    BlockingQueue       ConcurrentLinkedQueue
    Future              Exchanger
```
* 静态构造的对象都可以被安全的发布

#### 3.5.4 事实不可变对象(Effectively Immutable Object)
* 一个对象从技术上来看是可变的，但其状态在发布后不会再改变，这样的对象就是"事实不可变对象"
* 在没有额外同步的情况下，任何线程都可以安全的使用被安全发布的事实不可变对象。

#### 3.5.5 可变对象
* 对象的发布需求取决于它的可变性：
```text
1. 不可变对象可以通过任意机制来发布
2. 事实不可变对象必须通过安全方式来发布
3. 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来
```

#### 3.5.6 安全的共享对象
* 当发布一个对象时，必须明确的说明对象的访问方式。

### 第3章总结：
```text
在并发程序中使用和共享对象时，可以使用一些实用策略：
1. 线程封闭
    线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
2. 只读共享
    在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。
    共享的只读对象包括不可变对象和事实不可变对象。
3. 线程安全共享
    线程安全的对象在其内部实现同步，因此多个线程可以通过对象的共有接口来进行访问而不需要进一步的同步。
4. 保护对象
    被保护的对象只能通过持有特定的锁来访问。
    保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。    
```


