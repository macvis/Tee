Java并发编程实战  
--  

####前言
* 要点：  
    1. 线程也被称为轻量级进程
    2. 线程带来的风险：
        1) 安全性
        2) 活跃性：  
            在开发并发代码时，一定要注意线程安全性是不可破坏的
        3) 性能问题：  
            在多线程程序中，当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁的出现上下文切换操作，这种操作将带来极大的开销：  
            保存和恢复执行上下文，丢失局部性，并且CPU时间将更多的花在线程调度而不是线程运行上。
    4. 线程无处不在：  
        框架通过在框架线程中调用应用程序代码将并发性引入到程序中。在代码中将不可避免的访问应用程序状态，因此所有访问这些状态的代码路径都必须是线程安全的。  
    5. 几个在应用程序之外的线程中调用应用程序的代码(是不是守护线程?)  
        java.util.Timer;  
        各种Servlet;   
        RMI

###第一部分，基础知识  
####2.0 线程安全性
* 要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的(Shared)和可变的(Mutable)状态的访问
    * 共享，意味着变量可以由多个线程同时访问
    * 可变，意味着变量的值在其生命周期内可以发生变化
    - 一个对象是否需要是线程安全的，取决于它是否被多个线程访问
    - 要使得对象时线程安全的，就需要使用同步机制来协同对对象可变状态的访问
    - 在编写并发应用程序时，一种正确的编程方法就是：首先使代码正确运行，然后再提高代码的速度

####2.1 什么是线程安全性
* 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行文，那么就称这个类时线程安全的。  

示例1：一个无状态的Servlet
```java
@ThreadSafe
public class StatelessFactorizer implements Servlet{
    public void service(ServletRequest req, ServletResponse resp){
        java.math.BigInteger i = extractFromRequest(req);
        java.math.BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }
}
```
StatelessFactorizer是无状态的：既不包含任何域，也不包含任何对其他类中域的引用。
* 无状态对象一定是线程安全的。
    * 大多数Servlet都是无状态的。
    * 只有当Servlet在处理请求时需要保存一些信息，线程安全性才会成为一个问题   
    
####2.2 原子性  

示例2：在没有同步的情况下统计已处理请求数量的Servlet(不安全，不能这么写)
```java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet{
    private long count = 0;
    public long getCount(){
        return count;
    }
    public void service(ServletRequest req, ServletResponse res){
        java.math.BigInteger i = extractFromRequest(req);
        java.math.BigInteger[] factors = factor(i);
        count++;
        encodeIntoResponse(res, factors);
    }
}
```
上述类是非线程安全的，虽然能在单线程环境中正确运行，但是很可能会丢失一些更新操作。虽然递增操作count++是一种紧凑的语法，使其看上去只是一个操作，但这个操作并非原子的，因而它并不会作为一个不可分割的操作来执行  
* 在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：**竞态条件**。
####2.2.1 竞态条件  
* 当某个计算结果的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件
    * 最常见的竞态条件类型就是先检查后执行(check-then-act)操作，即通过一个可能失效的观测结果来决定下一步的动作  
    * 要获得正确的结果，必须取决于时间的发生时序。
* 竞态条件的本质：基于一种可能失效的观察结果来做出判断或者执行某个计算，举例：
```text
A和B约在一号大街的星巴克见面。
然后A赶到一号大街时却发现有两个星巴克。
于是A进入第一家星巴克，没有看到B，只好走出来。
就在A走出第一家星巴克的时候，B也赶到第一家星巴克，只是B从后门进的。
所以这就是一种失效的观察结果

即先检查，后执行
```
####2.2.2 延迟初始化中的竞态条件
* 延迟初始化：将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。
示例：延迟初始化中的竞态条件，不要这么做
```java
public class LazyInitRace{
    private ExpensiveObject instance = null;
    public ExpensiveObject getInstance(){
        if(instance == null){
            instance = new ExpensiveObject();
            return instance;
        }
    }
}
```
上述例子中，如果同时有两个线程执行getInstance，那么A看到instance为空的同时，B也在调用getInstance方法，那么此时的instance是否为空，要取决于不可预测的时序，包括线程的调度方式，以及A需要花费多长时间来初始化ExpensiveObject并设置Instance。如果当B检查时，instance为空没那么在两次调用getInstance时可能会得到不同的结果  
* 与大多数并发错误一样，竞态条件并不总是会产生错误，还需要某种不恰当的执行时序。
* 原子操作：  
假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作(包括该操作本身)来说，这个操作是一个已原子方式执行的操作。

```java
//程序2.4
@ThreadSafe
public class CountingFactorizer implements Servlet{
    private final AtomicLong count = new AtomicLong(0);
    
    public long getCount(){
        return count.get();
    }
    
    public void service(ServletRequest req, ServletResponse resp){
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        count.incrementAndGet();
        encodeIntoResponse(resp, factors);
    }
}
```
AtomicLong能保证所有对计数器状态的访问操作都是原子的。

####2.3.1 重入
* 概念：  
  当某个线程请求一个有其他线程持有的线程时，发出的请求线程就会阻塞。然而，由于内置的锁是可重入的，因此如果某个线程试图获得一个已经**由他自己持有**的锁，那么这个请求就会成功。
* 重入，意味着获取锁的操作的粒度是"线程"而不是"调用"  
  粒度：指的是一个方法内所包含的逻辑复杂度。若把一次调用视作一个逻辑，那么线程则具有多个逻辑，则粒度变大  
  
####2.4 用锁来保护状态
* 锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。  
  串行访问：意味着多个线程**依次**以独占的方式访问对象，而不是并发访问  
* 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的
* 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁

####2.5 活跃性与性能
* 尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享变量
* 通常，在**简单性**与性能之间存在着相互制约的因素，当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性(可能会破坏安全性)  
  简单性：指的是编码时的简单，例如用一大块synchronized/try-catch代码块将代码包裹起来
* 当执行时间较长的计算或者无法可能快速完成的操作时(网络I/O，控制台I/O)，一定不要持有锁

#### 3 对象的共享
#### 3.1 可见性
* 可见性中的错误总是会违背我们的直觉
* 重排序(Reordering)：  
1. 在没有同步的情况下，jvm允许cpu对操作顺序重新排序，以使jvm充分利用现代多核处理器的性能  
2. 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。
* 只要有数据在多个线程之间共享，就能正确的使用同步，得到我们想要的结果
#### 3.1.2 非原子的64位操作
* java内存模型要求，变量的读取操作和写入操作都必须是原子操作
* **但是**对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位操作。这就带来了非原子性操作的隐患  
#### 3.1.3 加锁与可见性
* 内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果
* 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步
#### 3.1.4 volatile变量
* volatile是一个比synchronized关键字更轻量级的同步机制
* 当一个变量被声明为volatile后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序
* 使用场景：  
1. 能简化代码的实现以及对同步策略的验证时；  
2. 确保它们自身状态的可见性；  
3. 确保它们所引用对象的状态的可见性；  
4. 标识一些重要的程序生命周期事件的发生(eg. 初始化或关闭)  
5. 通常用作某个操作完成、发生中断或者其他状态的标识，如下列代码中的asleep变量
```java
class Foo{
    volatile boolean asleep;

    public void foo(){
        while(asleep){
            countSomeSheep();
        }
    }
}
```
6. volatile的语义不足以确保递增操作的原子性，除非你能确保只有一个线程对变量执行写操作。
```text
例如你让一个volatile的integer自增（i++），其实要分成3步：
1）读取volatile变量值到local； 
2）增加变量的值；
3）把local的值写回，让其它的线程可见。

这3步的jvm指令为：
1 mov    0xc(%r10),%r8d ; Load
2 inc    %r8d           ; Increment
3 mov    %r8d,0xc(%r10) ; Store
4 lock   addl $0x0,(%rsp) ; StoreLoad Barrier
注意最后一步是内存屏障。

什么是内存屏障（Memory Barrier）？
内存屏障（memory barrier）是一个CPU指令。
基本上，它是这样一条指令： 
a) 确保一些特定操作执行的顺序； 
b) 影响一些数据的可见性(可能是某些指令执行后的结果)。
编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。
插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。
内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，
这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。

内存屏障（memory barrier）和volatile什么关系？
上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，
在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：
1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。
2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。

volatile为什么没有原子性?
明白了内存屏障（memory barrier）这个CPU指令，回到前面的JVM指令：
从Load到store到内存屏障，一共4步，
其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，
但中间的几步（从Load到Store）是不安全的，中间如果其他的CPU修改了值将会丢失。
```
7. 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性
8. 当且仅当满足以下所有条件时，才可以使用volatile变量  
* 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值
* 该变量不会与其他状态变量一起纳入不变性条件中
* 在访问变量时不需要加锁

#### 3.2 发布与逸出
* 发布：发布一个对象指的是，是对象能够在当前作用域之外的代码中使用。
* 逸出：当某个不应该被发布的对象被发布时，这种情况就是逸出。
* 不要在构造过程中使this引用逸出
* 当对象在构造函数中创建一个线程时，无论是显式创建(通过将它传给构造函数)，还是隐式创建(由于Thread或Runnable是该对象的一个内部类)，this引用都会被新创建的线程共享。
* 在构造函数中调用一个可改写的实例方法时，同样对导致this引用在构造过程中逸出。

#### 3.3 线程封闭
* 数据的共享需要使用同步。
* 线程封闭：如果是仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭
* 线程封闭同时也是实现线程安全性最简单的方式之一。
* 当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身就不是线程安全的。
* 线程封闭的常见应用是JDBC的Connection对象。

#### 3.3.1 Ad-hoc线程封闭
* 概念：维护线程封闭性的职责完全由程序实现来承担。
* 在某些情况下，单线程子系统提供的简便性要胜过Ad-hoc线程封闭技术的脆弱性，另外一个原因也是为了避免死锁。
* volatile变量还存在一种特殊的线程封闭。只要能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全的在这些共享的volatile变量上执行"读取-修改-写入"的操作。
* volatile变量的可见性还确保了其他线程能看到最新的值。
* Ad-hoc因为比较脆弱，所以尽量少用。更多的使用栈封闭或ThreadLocal类